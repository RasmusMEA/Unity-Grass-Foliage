#pragma kernel DistributeVegetation
#pragma kernel GenerateInstanceLODs
#pragma kernel ComputePrefixSum
#pragma kernel CullInstances

// Imports
#include "TextureMaps.hlsl"
#include "Assets/ShaderLibrary/Common/CommonLibrary.hlsl"
#include "Assets/ShaderLibrary/Common/Rendering.hlsl"
#include "Assets/HiZ-Culling/HiZOcclusionCulling.hlsl"

// Jittered grid sampling
int _Seed;
uint2 _CellCount;
float _CellSize;

// Vegetation data per vegetation type
uint _VegetationCount;                      // Number of different vegetation types
struct VegetationData {
    float3 offset;                          // Offset of the vegetation instance
    float3 scale;                           // Scale of the vegetation instance
    float3 rotation;                        // Rotation of the vegetation instance

    float size;                             // Size of the vegetation instance, used for culling
    float alignToNormal;                    // Align the instance to the normal of the terrain (0 = none, 1 = fully aligned)

    int influenceMask;                      // Influence mask for the vegetation influences
};
StructuredBuffer<VegetationData> _VegetationData;

// Influence Data containing the influence weight given a value in range [0.0, 1.0]
// Data Type Order: (Height, Water Depth, Relative Height, Slope, Moisture)
uint _DataPoints;                           // Number of data points per vegetation influence
StructuredBuffer<float> _InfluenceData;     // Offset: (VegetationIndex * DataTypeCount + DataTypeIndex) * _DataPoints + <Value> * (_DataPoints - 1)

// LOD data, containing the LOD screen size scales in range [0.0, 1.0]
uint _LODCount;                             // Number of LODs per vegetation instance
StructuredBuffer<float> _LODData;           // Offset: VegetationIndex * _LODCount + <LODIndex>

// Resulting instance data, vegetationIndex for sorting instances and objectToWorld for Instancing
struct InstancePosition {
    int vegetationIndex;
    float4x4 objectToWorld;
};

// Result buffers for the vegetation instances
uint _MaxInstanceCount;                                         // Maximum number of vegetation instances
RWStructuredBuffer<uint> _InstanceCount;                        // Total number of vegetation instances
RWStructuredBuffer<uint4> _InstanceIndex;                       // (<startIndex, instanceCount>, sortedCount, visibleCount) for each vegetation type
RWStructuredBuffer<InstancePosition> _InstancePositions;        // Vegetation instances to be sorted
StructuredBuffer<InstancePosition> _Positions;                  // Read buffer for the vegetation instances
RWStructuredBuffer<float4x4> _InstancesSorted;                  // Object to world matrix for each instance, sorted and culled by visibility

float InterpolateInfluence(int vegetationIndex, int dataType, float value) {
    float index = (vegetationIndex * 5 + dataType) * _DataPoints + value * (_DataPoints - 1);
    float influence = _InfluenceData[floor(index)] * frac(index) + _InfluenceData[ceil(index)] * (1 - frac(index));
    return saturate(influence);
}

float CalculateWeight(int vegetationIndex, float4 terrainData, float3 normal) {
    float weight = 1.0f;
    
    // Get the influence mask for the vegetation instance
    int mask = _VegetationData[vegetationIndex].influenceMask;

    weight *= mask & 1 ? InterpolateInfluence(vegetationIndex, 0, terrainData.x) : 1.0f;
    weight *= mask & 2 ? InterpolateInfluence(vegetationIndex, 1, terrainData.y + (1 / _DataPoints) * terrainData.y > 0) : 1.0f;
    weight *= mask & 4 ? InterpolateInfluence(vegetationIndex, 2, terrainData.z) : 1.0f;
    weight *= mask & 8 ? InterpolateInfluence(vegetationIndex, 3, 1 - normal.z) : 1.0f;
    weight *= mask & 16 ? InterpolateInfluence(vegetationIndex, 4, terrainData.w) : 1.0f;

    return weight;
}

[numthreads(8,8,1)]
void DistributeVegetation(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _CellCount.x || id.y >= _CellCount.y) { return; }

    // Get the current grid cell center position
    float2 cellCenter = (id.xy - _CellCount / 2.0) * 2.0 * _CellSize + _CellSize / 2.0 + _PositionWS.xz; // Needs to round to cell size
    
    // Random numbers
    float hash = dot(floor(cellCenter * 100) / 100, float3(6047, 4871, 5237).xy);
    uint positionHash = asuint(rand(hash)) ^ asuint(hash) ^ _Seed;
    float r = rand(positionHash * 701);
    float r2 = rand(positionHash * 461);

    // Jitter the position
    float2 jitter = float2(r - 0.5, r2 - 0.5) * _CellSize;
    float3 positionWS = float3(cellCenter.x + jitter.x, 0, cellCenter.y + jitter.y);

    // Get terrain data for the cell
    bool validTerrain;
    bool validNormal;
    float4 terrainData = SampleTextureWorldPosition(_TerrainMapView, sampler_TerrainMapView, positionWS, validTerrain);
    float3 normal = SampleTextureWorldPosition(_NormalMapView, sampler_NormalMapView, positionWS, validNormal).xyz;
    if (!validTerrain || !validNormal) { return; }

    // Set the height of the position
    positionWS.y = (terrainData.x - 0.5) * _HeightScale;

    // Count all vegetation instances that is above a chosen threshold
    float threshold = rand(positionHash * 1031);
    float totalWeight = 0;
    int count = 0;
    for (uint i = 0; i < _VegetationCount; i++) {
        float weight = CalculateWeight(i, terrainData, normal);
        count += weight > threshold;
        totalWeight += weight * (weight > threshold);
    }

    // Pick at random a vegetation instance based on the weight
    float currentWeight = rand(positionHash * 4871 ^ positionHash) * totalWeight;
    int vegetationIndex = -1;
    for (i = 0; i < _VegetationCount; i++) {
        float weight = CalculateWeight(i, terrainData, normal);
        
        // If above threshold, subtract weight from current weight and check if current weight is <= 0
        if (weight <= threshold) { continue; }
        if ((currentWeight -= weight) <= 0) {
            vegetationIndex = i;
            break;
        }
    }

    // No vegetation instance was picked
    if (vegetationIndex == -1) { return; }

    // Check instance count
    uint instanceCount;
    InterlockedAdd(_InstanceCount[0], 1, instanceCount);

    // If no more instances can be added, remove the instance and return
    if (instanceCount >= _MaxInstanceCount) {
        InterlockedAdd(_InstanceCount[0], -1);
        return;
    }

    // Random scale and rotation around normal
    VegetationData vegetationData = _VegetationData[vegetationIndex];
    float3 scale = vegetationData.scale + (rand(positionHash * 6047) * 2 - 1) * 0.2;
    float rotation = rand(positionHash * 5237) * 2 * 3.14159265359;
    float4x4 objectToWorld = float4x4(
        float4(cos(rotation) * scale.x, 0, sin(rotation) * scale.x, positionWS.x),
        float4(0, scale.y, 0, positionWS.y),
        float4(-sin(rotation) * scale.z, 0, cos(rotation) * scale.z, positionWS.z),
        float4(0, 0, 0, 1)
    );

    // Write instance data
    InstancePosition instancePosition = (InstancePosition)0;
    instancePosition.vegetationIndex = vegetationIndex * _LODCount;
    instancePosition.objectToWorld = objectToWorld;
    _InstancePositions[instanceCount] = instancePosition;
    InterlockedAdd(_InstanceIndex[vegetationIndex * _LODCount].y, 1);
}

[numthreads(64,1,1)]
void GenerateInstanceLODs(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _InstanceCount[0]) { return; }

    // Get current instance
    InstancePosition instance = _InstancePositions[id.x];
    int vegetationIndex = instance.vegetationIndex - instance.vegetationIndex % _LODCount;

    // Calculate the LOD for the instance
    float3 positionWS = float3(instance.objectToWorld[0][3], instance.objectToWorld[1][3], instance.objectToWorld[2][3]);
    float realtiveScreenSize = screenRelativeHeight(positionWS, _VegetationData[vegetationIndex].size);
    float distance = length(positionWS - _CameraPositionWS);
    int lod = 0;
    for (uint i = 0; i < _LODCount; i++) {
        lod = i;
        if (max(0, 1 - distance / 1500.0f) >= _LODData[vegetationIndex + i]) {
            break;
        }
    }

    // Write LOD data to the instance
    InterlockedAdd(_InstanceIndex[instance.vegetationIndex].y, -1);
    InterlockedAdd(_InstanceIndex[vegetationIndex + lod].y, 1);
    instance.vegetationIndex = vegetationIndex + lod;
    _InstancePositions[id.x] = instance;
}

[numthreads(1,1,1)]
void ComputePrefixSum(uint3 id : SV_DispatchThreadID) {
    if (id.x >= 1) { return; }

    // Calculate the prefix sum for the instance index buffer
    uint sum = 0;
    for (uint i = 0; i < _VegetationCount * _LODCount; i++) {
        _InstanceIndex[i].x = sum;
        sum += _InstanceIndex[i].y;

        // Reset the offset counters
        _InstanceIndex[i].z = 0;
        _InstanceIndex[i].w = 0;
    }
}

[numthreads(64,1,1)]
void CullInstances(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _InstanceCount[0]) { return; }
    bool cull = false;

    // Get current instance, position and radius
    InstancePosition instance = _Positions[id.x];
    float3 positionWS = float3(instance.objectToWorld[0][3], instance.objectToWorld[1][3], instance.objectToWorld[2][3]);
    float radius = _VegetationData[instance.vegetationIndex].size;

    // Frustum cull
    cull = cull | FrustumCull(positionWS, radius);

    if (cull) return;

    // Hi-Z occlusion cull
    // cull = cull | OcclusionCull(positionWS, radius);

    if (cull) return;

    // Write instance data
    uint instanceOffset = 0;
    InterlockedAdd(_InstanceIndex[instance.vegetationIndex].w, 1, instanceOffset);
    _InstancesSorted[_InstanceIndex[instance.vegetationIndex].x + instanceOffset] = instance.objectToWorld;
}
