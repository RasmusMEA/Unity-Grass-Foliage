#pragma kernel DistributeVegetation
#pragma kernel ComputePrefixSum
#pragma kernel SortInstances

// Imports
#include "TextureMaps.hlsl"
#include "Assets/ShaderLibrary/Common/CommonLibrary.hlsl"

// Jittered grid sampling
int _Seed;
uint2 _CellCount;
float _CellSize;

// Influence data for all vegetation instances, containing influence data in the range [0.0, 1.0]
// Packing:
// 1: Height
// 2: Water Depth
// 3: Relative Height
// 4: Slope
// 5: Moisture
uint _DataPoints;                           // Number of data points per influence curve
uint _VegetationCount;                      // Number of different vegetation types
StructuredBuffer<float> _InfluenceData;     // Offset: VegetationIndex * _DataPoints * 5 + DataType * _DataPoints

// Resulting instance data, vegetationIndex for sorting instances and objectToWorld for Instancing
struct InstancePosition {
    int vegetationIndex;
    float4x4 objectToWorld;
};

// Result buffers for the vegetation instances
uint _MaxInstanceCount;                                         // Maximum number of vegetation instances
RWStructuredBuffer<uint> _InstanceCount;                        // Total number of vegetation instances
RWStructuredBuffer<InstancePosition> _InstancePositions;        // Vegetation instances to be sorted
StructuredBuffer<InstancePosition> _Positions;                  // Read buffer for the vegetation instances
RWStructuredBuffer<uint2> _InstanceIndex;                       // <instanceCount, startIndex> for each vegetation type
RWStructuredBuffer<uint> _InstanceOffset;                       // Local offset when sorting for each vegetation type
RWStructuredBuffer<float4x4> _InstanceData;                     // Object to world matrix for each instance, sorted by vegetation type

float InterpolateInfluence(int vegetationIndex, int dataType, float value) {
    float index = vegetationIndex * _DataPoints * 5 + _DataPoints * dataType + value * (_DataPoints - 1);
    float influence = _InfluenceData[floor(index)] * frac(index) + _InfluenceData[max(_DataPoints - 1, ceil(index))] * (1 - frac(index));
    return saturate(influence);
}

float CalculateWeight(int vegetationIndex, float4 terrainData, float3 normal) {
    float weight = 1.0f;
    weight *= InterpolateInfluence(vegetationIndex, 0, terrainData.x);
    weight *= InterpolateInfluence(vegetationIndex, 1, terrainData.y + (1 / _DataPoints) * terrainData.y > 0);
    weight *= InterpolateInfluence(vegetationIndex, 2, terrainData.z);
    weight *= InterpolateInfluence(vegetationIndex, 3, 1 - normal.z);
    weight *= InterpolateInfluence(vegetationIndex, 4, terrainData.w);
    return weight;
}

[numthreads(8,8,1)]
void DistributeVegetation(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _CellCount.x || id.y >= _CellCount.y) { return; }

    // Get the current grid cell center position
    float2 cellCenter = (id.xy - _CellCount / 2.0) * _CellSize + _CellSize / 2.0;
    
    // Random numbers
    float hash = dot(floor(cellCenter * 100) / 100, float3(6047, 4871, 5237).xy);
    uint positionHash = asuint(rand(hash)) ^ asuint(hash) ^ _Seed;
    float r = rand(positionHash * 701);
    float r2 = rand(positionHash * 461);

    // Jitter the position
    float2 jitter = float2(r - 0.5, r2 - 0.5) * _CellSize;
    float3 positionWS = float3(cellCenter.x + jitter.x, 0, cellCenter.y + jitter.y);

    // Get terrain data for the cell
    bool validTerrain;
    bool validNormal;
    float4 terrainData = SampleTextureWorldPosition(_TerrainMapView, sampler_TerrainMapView, positionWS, validTerrain);
    float3 normal = SampleTextureWorldPosition(_NormalMapView, sampler_NormalMapView, positionWS, validNormal).xyz;
    if (!validTerrain || !validNormal) { return; }

    // Set the height of the position
    positionWS.y = (terrainData.x - 0.5) * 150;

    // Count all vegetation instances that is above a chosen threshold
    float threshold = rand(positionHash * 1031);
    float totalWeight = 0;
    int count = 0;
    for (uint i = 0; i < _VegetationCount; i++) {
        float weight = CalculateWeight(i, terrainData, normal);
        count += weight > threshold;
        totalWeight += weight * (weight > threshold);
    }

    // Pick at random a vegetation instance based on the weight
    float currentWeight = rand(positionHash * 4871 ^ positionHash) * totalWeight;
    int vegetationIndex = -1;
    for (i = 0; i < _VegetationCount; i++) {
        float weight = CalculateWeight(i, terrainData, normal);
        
        // If above threshold, subtract weight from current weight and check if current weight is <= 0
        if (weight <= threshold) { continue; }
        if ((currentWeight -= weight) <= 0) {
            vegetationIndex = i;
            break;
        }
    }

    // No vegetation instance was picked
    if (vegetationIndex == -1) { return; }

    // Check instance count
    uint instanceCount;
    InterlockedAdd(_InstanceCount[0], 1, instanceCount);

    // If no more instances can be added, remove the instance and return
    if (instanceCount >= _MaxInstanceCount) {
        InterlockedAdd(_InstanceCount[0], -1, instanceCount);
    }

    // Random scale and rotation around normal
    float scale = 1.0 + (rand(positionHash * 6047) * 2 - 1) * 0.2;
    float rotation = rand(positionHash * 5237) * 2 * 3.14159265359;
    float4x4 objectToWorld = float4x4(
        float4(cos(rotation) * scale, 0, sin(rotation) * scale, positionWS.x),
        float4(0, scale, 0, positionWS.y),
        float4(-sin(rotation) * scale, 0, cos(rotation) * scale, positionWS.z),
        float4(0, 0, 0, 1)
    );

    // Normal transformation
    // float3 normalWS = float3(normal.x, normal.z, normal.y);
    // float3 tangent = normalize(cross(normalWS, float3(1, 1, 1)));
    // float3 bitangent = cross(normalWS, tangent);
    // float4x4 TBN = transpose(float4x4(
    //     float4(tangent, 0),
    //     float4(bitangent, 0),
    //     float4(normalWS, 0),
    //     float4(0, 0, 0, 1)
    // ));

    // Write instance data
    InstancePosition instancePosition = (InstancePosition)0;
    instancePosition.vegetationIndex = vegetationIndex;
    instancePosition.objectToWorld = objectToWorld; //mul(objectToWorld, TBN);
    _InstancePositions[instanceCount] = instancePosition;
    InterlockedAdd(_InstanceIndex[vegetationIndex].x, 1);
}

[numthreads(1,1,1)]
void ComputePrefixSum(uint3 id : SV_DispatchThreadID) {
    if (id.x >= 1) { return; }

    // Calculate the prefix sum for the instance index buffer
    uint sum = 0;
    for (uint i = 0; i < _VegetationCount; i++) {
        _InstanceIndex[i].y = sum;
        sum += _InstanceIndex[i].x;

        // Reset the instance offset buffer
        _InstanceOffset[i] = 0;
    }
}

[numthreads(64,1,1)]
void SortInstances(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _InstanceCount[0]) { return; }

    // Get current instance
    InstancePosition instance = _Positions[id.x];

    // Allocate a slot for the instance and insert it into the instance buffer
    uint instanceOffset = 0;
    InterlockedAdd(_InstanceOffset[instance.vegetationIndex], 1, instanceOffset);
    _InstanceData[_InstanceIndex[instance.vegetationIndex].y + instanceOffset] = instance.objectToWorld;
}
