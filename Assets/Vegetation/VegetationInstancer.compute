#pragma kernel DistributeVegetation
#pragma kernel GenerateInstanceLODs
#pragma kernel ComputePrefixSum
#pragma kernel CullInstances

// Imports
#include "TextureMaps.hlsl"
#include "Assets/Terrain/WorldGenerationNew.hlsl"
#include "Assets/ShaderLibrary/Common/CommonLibrary.hlsl"
#include "Assets/ShaderLibrary/Common/Rendering.hlsl"
#include "Assets/HiZ-Culling/HiZOcclusionCulling.hlsl"

// Jittered grid sampling
int _Seed;
uint2 _CellCount;
float _CellSize;

struct VegetationType {

    // Prefab Indexing
    uint startIndex;
    uint prefabCount;

    // Bit flags
    // (0-5): Height, Water Depth, Relative Height, Slope, Moisture
    // (6-31): Unused
    uint flags;
};

struct VegetationPrefab {

    // Vegetation index and prefab weight
    uint vegetationIndex;
    float weight;

    // Transform
    float3 position;
    float3 rotation;
    float3 scale;
    
    // LOD & indexing
    uint startIndex;                        // Start index of the LODs
    uint lodCount;                          // Number of LODs
    float radius;                           // Radius of the vegetation instance, used for culling

    float alignToNormal;                    // Align instance to normal of terrain (0 = none, 1 = fully aligned)                
};

// Vegetation input data
uint _VegetationCount;
StructuredBuffer<VegetationType> _VegetationTypes;
StructuredBuffer<VegetationPrefab> _VegetationPrefabs;

// Prefab LOD & Influence data
uint _DataPoints;
StructuredBuffer<float> _PrefabLODs;
StructuredBuffer<float> _VegetationInfluenceWeights;

// Resulting instance data, vegetationIndex for sorting instances and objectToWorld for Instancing
struct InstancePosition {
    int prefabIndex;
    int lodIndex;
    float4x4 objectToWorld;
};

// Result buffers for the vegetation instances
uint _MaxInstanceCount;                                         // Maximum number of vegetation instances
RWStructuredBuffer<uint> _InstanceCount;                        // Total number of vegetation instances
RWStructuredBuffer<uint3> _InstanceIndex;                       // (startIndex, instanceCount, visibleCount) for each vegetation type
RWStructuredBuffer<InstancePosition> _InstancePositions;        // Vegetation instances to be sorted
StructuredBuffer<InstancePosition> _Positions;                  // Read buffer for the vegetation instances
RWStructuredBuffer<float4x4> _InstancesSorted;                  // Object to world matrix for each instance, sorted and culled by visibility

float SampleWeight(int vegetationIndex, int dataType, float value) {
    float index = (vegetationIndex * 5 + dataType) * _DataPoints + value * (_DataPoints - 1);
    float influence = _VegetationInfluenceWeights[floor(index)] * frac(index) + _VegetationInfluenceWeights[ceil(index)] * (1 - frac(index));
    return saturate(influence);
}

float CalculateWeight(int vegetationIndex, float4 terrainData, float3 normal) {
    float weight = 1.0f;
    
    // Get the influence mask for the vegetation instance
    int flags = _VegetationTypes[vegetationIndex].flags;

    weight *= flags & 1 ? SampleWeight(vegetationIndex, 0, terrainData.x) : 1.0f;
    weight *= flags & 2 ? SampleWeight(vegetationIndex, 1, terrainData.y + (1 / _DataPoints) * terrainData.y > 0) : 1.0f;
    weight *= flags & 4 ? SampleWeight(vegetationIndex, 2, terrainData.z) : 1.0f;
    weight *= flags & 8 ? SampleWeight(vegetationIndex, 3, 1 - normal.z) : 1.0f;
    weight *= flags & 16 ? SampleWeight(vegetationIndex, 4, terrainData.w) : 1.0f;

    return weight;
}

[numthreads(8,8,1)]
void DistributeVegetation(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _CellCount.x || id.y >= _CellCount.y) { return; }

    // Get the current grid cell center position
    float2 cellCenter = ((id.xy - _CellCount / 2.0) + 0.5) * _CellSize + (round(_PositionWS / _CellSize) * _CellSize).xz;
    
    // Random numbers
    float hash = dot(floor(cellCenter * 100) / 100, float3(6047, 4871, 5237).xy);
    uint positionHash = asuint(rand(hash)) ^ asuint(hash) ^ _Seed;
    float r = rand(positionHash * 701);
    float r2 = rand(positionHash * 461);

    // Jitter the position
    float2 jitter = float2(r - 0.5, r2 - 0.5) * _CellSize;
    float3 positionWS = float3(cellCenter.x + jitter.x, 0, cellCenter.y + jitter.y);

    // Get terrain data for the cell
    bool validTerrain;
    bool validNormal;
    float4 terrainData = SampleTextureWorldPosition(_TerrainMapView, sampler_TerrainMapView, positionWS, validTerrain);
    float3 terrainNormal = SampleTextureWorldPosition(_NormalMapView, sampler_NormalMapView, positionWS, validNormal).xyz;
    float3 normal = normalize(terrainNormal.xzy * 2 - 1);

    if (!validTerrain || !validNormal) { return; }

    // Set the height of the position
    positionWS.y = SampleHeight(positionWS.x, positionWS.z);

    // Count all vegetation instances that is above a chosen threshold
    float threshold = rand(positionHash * 1031);
    float totalWeight = 0;
    int count = 0;
    for (uint i = 0; i < _VegetationCount; i++) {
        float weight = CalculateWeight(i, terrainData, terrainNormal);
        count += weight > threshold;
        totalWeight += weight * (weight > threshold);
    }

    // Pick at random a vegetation instance based on the weight
    float currentWeight = rand(positionHash * 4871 ^ positionHash) * totalWeight;
    int vegetationIndex = -1;
    for (i = 0; i < _VegetationCount; i++) {
        float weight = CalculateWeight(i, terrainData, terrainNormal);
        
        // If above threshold, subtract weight from current weight and check if current weight is <= 0
        if (weight <= threshold) { continue; }
        if ((currentWeight -= weight) <= 0) {
            vegetationIndex = i;
            break;
        }
    }

    // No vegetation instance was picked
    if (vegetationIndex == -1) { return; }

    // Pick at random a vegetation prefab based on the weight
    uint prefabIndex = _VegetationTypes[vegetationIndex].startIndex;
    uint prefabCount = _VegetationTypes[vegetationIndex].prefabCount;
    float prefabWeight = rand(positionHash * 5237 ^ positionHash);
    for (i = 0; i < prefabCount; i++) {
        float weight = _VegetationPrefabs[prefabIndex + i].weight;
        if ((prefabWeight -= weight) <= 0) {
            prefabIndex += i;
            break;
        }
    }
    if (prefabWeight > 0) { return; }

    // Check instance count, if no more instances can be added, remove the instance and return
    uint instanceCount;
    InterlockedAdd(_InstanceCount[0], 1, instanceCount);
    if (instanceCount >= _MaxInstanceCount) {
        InterlockedAdd(_InstanceCount[0], -1);
        return;
    }

    // Calculate the RotationScale matrix
    VegetationPrefab prefab = _VegetationPrefabs[prefabIndex];
    float rotation = rand(positionHash * 5237) * 2 * 3.14159265359;
    float3x3 rsMatrix = mul(
        RotateTo(slerp(float3(0, 1, 0), normal, prefab.alignToNormal)),
        mul(
            RotateAroundAxis(rotation, float3(0, 1, 0)),
            float3x3(
                float3(prefab.scale.x, 0, 0),
                float3(0, prefab.scale.y, 0),
                float3(0, 0, prefab.scale.z)
            )
        )
    );

    // Create the object to world matrix
    float4x4 objectToWorld = float4x4(
        float4(rsMatrix[0], positionWS.x),
        float4(rsMatrix[1], positionWS.y),
        float4(rsMatrix[2], positionWS.z),
        float4(0, 0, 0, 1)
    );

    // Write instance data
    InstancePosition instancePosition = (InstancePosition)0;
    instancePosition.prefabIndex = prefabIndex;
    instancePosition.lodIndex = prefabIndex;
    instancePosition.objectToWorld = objectToWorld;

    _InstancePositions[instanceCount] = instancePosition;
    InterlockedAdd(_InstanceIndex[prefabIndex].y, 1);
}

[numthreads(64,1,1)]
void GenerateInstanceLODs(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _InstanceCount[0]) { return; }

    // Get current instance
    InstancePosition instance = _InstancePositions[id.x];
    VegetationPrefab prefab = _VegetationPrefabs[instance.prefabIndex];

    // Calculate the LOD for the instance
    float3 positionWS = float3(instance.objectToWorld[0][3], instance.objectToWorld[1][3], instance.objectToWorld[2][3]);
    float radius = prefab.radius * max(prefab.scale.x, max(prefab.scale.y, prefab.scale.z));
    float realtiveScreenSize = screenSpaceHeight(positionWS, radius);
    uint lod = 0;
    for (uint i = 0; i < prefab.lodCount; i++) {
        lod = i;
        if (realtiveScreenSize >= _PrefabLODs[prefab.startIndex + i]) {
            break;
        }
    }

    // // Outside of LOD range, to be culled
    // if (lod == prefab.lodCount && !(realtiveScreenSize >= _PrefabLODs[prefab.startIndex + lod])) {
    //     return; 
    // }
 
    // Add the instance to the new LOD
    InterlockedAdd(_InstanceIndex[instance.lodIndex].y, -1);
    InterlockedAdd(_InstanceIndex[prefab.startIndex + lod].y, 1);
    instance.lodIndex = prefab.startIndex + lod;
    _InstancePositions[id.x] = instance;
}

[numthreads(1,1,1)]
void ComputePrefixSum(uint3 id : SV_DispatchThreadID) {
    if (id.x >= 1) { return; }

    // Calculate the prefix sum for the instance index buffer
    uint sum = 0;
    for (uint i = 0; i < _InstanceIndex.Length; i++) {
        _InstanceIndex[i].x = sum;
        sum += _InstanceIndex[i].y;

        // Reset the offset counters
        _InstanceIndex[i].z = 0;
    }
}

[numthreads(64,1,1)]
void CullInstances(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _InstanceCount[0]) { return; }
    bool cull = false;

    // Get current instance, position and radius
    InstancePosition instance = _Positions[id.x];
    VegetationPrefab prefab = _VegetationPrefabs[instance.prefabIndex];
    float3 positionWS = float3(instance.objectToWorld[0][3], instance.objectToWorld[1][3], instance.objectToWorld[2][3]);
    float radius = prefab.radius * max(prefab.scale.x, max(prefab.scale.y, prefab.scale.z));

    // Frustum cull
    cull = cull | FrustumCull(positionWS, radius);

    if (cull) return;

    // Hi-Z occlusion cull
    // cull = cull | OcclusionCull(positionWS, radius);

    if (cull) return;

    // Write instance data
    uint instanceOffset = 0;
    InterlockedAdd(_InstanceIndex[instance.lodIndex].z, 1, instanceOffset);
    _InstancesSorted[_InstanceIndex[instance.lodIndex].x + instanceOffset] = instance.objectToWorld;
}
