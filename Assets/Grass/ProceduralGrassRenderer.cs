using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

// ProceduralGrassRenderer is a script that generates grass on a mesh using a compute shader.
// Runs in the editor for quick iteration.
//
// The grass is generated by sampling the mesh triangles and creating grass blades on them,
// hence the (DefaultExecutionOrder +1) to ensure that the script runs after potential GPU mesh modifications
// and requires a pre-existing MeshFilter and MeshRenderer component to be attached to the GameObject.
[ExecuteInEditMode, DefaultExecutionOrder(+1), RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class ProceduralGrassRenderer : MonoBehaviour {

    // Component references.
    private MeshRenderer meshRenderer;
    private MeshFilter meshFilter;

    // Compute shader and material references.
    [Tooltip("The compute shader to use to generate the grass.")]
    [SerializeField] private ComputeShader grassComputeShader;
    [Tooltip("The material to use to render the grass.")]
    [SerializeField] private Material material;

    [Header("Grass Settings")]
    [SerializeField] private GrassSettings m_grassSettings;
    [SerializeField] public Space sampleSpace = Space.World;

    // Flag to check if the renderer has been initialized.
    private bool _isInitialized = false;

    // Instantiated compute shader and material.
    private ComputeShader instantiatedGrassComputeShader;       // Compute shader to generate the grass.
    private Material instantiatedMaterial;                      // Material to render the grass.

    // Local instance compute shader variables.
    private int idGrassKernel;
    private Vector3Int dispatchSize;

    // Buffers that store the mesh data.
    private GraphicsBuffer indexBuffer;
    private GraphicsBuffer vertexBuffer;

    // Indirect draw buffers for GPU instancing.
    private ComputeBuffer grassInstancesBuffer;                                                 // Buffer to store the generated grass triangles.
    private const int GRASS_INSTANCE_STRIDE = sizeof(float) * 15 + sizeof(int) * 1;             // The size of a singular element in the compute buffers.
    private GraphicsBuffer indirectDrawIndexedArgs;                                             // Buffer to store the arguments for the draw command.  

    // The data to reset the indirectDrawIndexedArgs buffer with each frame.
    // { indexCountPerInstance, instanceCount, startindex, baseVertexIndex, startInstance }.
    private uint[] indirectDrawIndexedArgsReset = new uint[5] { 0, 0, 0, 0, 0 };

    void OnEnable() {

        // If initialized, call OnDisable to clean up.
        if (_isInitialized) { OnDisable(); }

        // Get mesh data, if no mesh then return.
        meshFilter = GetComponent<MeshFilter>();
        meshRenderer = GetComponent<MeshRenderer>();
        Mesh mesh = meshFilter.sharedMesh;

        // Check if the mesh, compute shader, and material are set.
        if (mesh == null || grassComputeShader == null || material == null) {
            Debug.Assert(mesh != null, "Mesh is not set.", this);
            Debug.Assert(grassComputeShader != null, "Compute shader is not set.", this);
            Debug.Assert(material != null, "Material is not set.", this);
            return;
        }

        // Generate grass mesh if no mesh is set.
        if (m_grassSettings.grassBladeMesh == null) {
            m_grassSettings.grassBladeMesh = new Mesh();
            
            m_grassSettings.grassBladeMesh.vertices = new Vector3[] {
                new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(-1, 0, 1/3f),
                new Vector3(1, 0, 1/3f), new Vector3(-1, 0, 2/3f), new Vector3(1, 0, 2/3f),
                new Vector3(0, 0, 1)
            };
            m_grassSettings.grassBladeMesh.triangles = new int[] { 
                0, 1, 2,
                1, 3, 2,
                2, 3, 4,
                3, 5, 4,
                4, 5, 6
            };
            m_grassSettings.grassBladeMesh.uv = new Vector2[] { 
                new Vector2(0, 0), new Vector2(1, 0), new Vector2(0, 1/3f),
                new Vector2(1, 1/3f), new Vector2(0, 2/3f), new Vector2(1, 2/3f),
                new Vector2(0.5f, 1)
            };

            // m_grassSettings.grassBladeMesh.vertices = new Vector3[] { new Vector3(-1, 0, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1) };
            // m_grassSettings.grassBladeMesh.triangles = new int[] { 0, 1, 2 };
            // m_grassSettings.grassBladeMesh.uv = new Vector2[] { new Vector2(0, 0), new Vector2(1, 0), new Vector2(0.5f, 1) };

            // Billboard grass mesh.
            // m_grassSettings.grassBladeMesh.vertices = new Vector3[] { new Vector3(0.5f, 0, 0), new Vector3(0.5f, 0, 1), new Vector3(-0.5f, 0, 1), new Vector3(-0.5f, 0, 0) };
            // m_grassSettings.grassBladeMesh.triangles = new int[] { 0, 1, 2, 0, 2, 3 };
            // m_grassSettings.grassBladeMesh.uv = new Vector2[] { new Vector2(1, 0), new Vector2(1, 1), new Vector2(0, 1), new Vector2(0, 0) };
        }

        // Instantiate the compute shader and material.
        instantiatedGrassComputeShader = Instantiate(grassComputeShader);
        instantiatedMaterial = Instantiate(material);

        // Set the grass sampling space.
        if (sampleSpace == Space.Self) {
            instantiatedGrassComputeShader.EnableKeyword("OBJECT_SPACE");
        } else if (sampleSpace == Space.World) {
            instantiatedGrassComputeShader.EnableKeyword("WORLD_SPACE");
        }

        // Cache the compute shader kernel.
        idGrassKernel = instantiatedGrassComputeShader.FindKernel("Main");

        // Calculate the total number of grass triangles.
        int sourceTriangleCount = mesh.triangles.Length / 3;

        // Get the vertex and index buffers from the mesh.
        mesh.indexBufferTarget |= GraphicsBuffer.Target.Raw;
        mesh.vertexBufferTarget |= GraphicsBuffer.Target.Raw;
        ProceduralTerrainRenderer terrainRenderer = GetComponent<ProceduralTerrainRenderer>();
        indexBuffer = mesh.GetIndexBuffer();
        vertexBuffer = mesh.GetVertexBuffer(0);

        // Set vertex buffer and other data for the compute shader.
        instantiatedGrassComputeShader.SetBuffer(idGrassKernel, "_IndexBuffer", indexBuffer);
        instantiatedGrassComputeShader.SetBuffer(idGrassKernel, "_VertexBuffer", vertexBuffer);

        instantiatedGrassComputeShader.SetInt("_IndexCount", (int)mesh.GetIndexCount(0));
        instantiatedGrassComputeShader.SetInt("_VertexCount", mesh.vertexCount);
        instantiatedGrassComputeShader.SetInt("_IndexStride", mesh.indexFormat == IndexFormat.UInt32 ? 4 : 2);
        instantiatedGrassComputeShader.SetInt("_VertexStride", mesh.GetVertexBufferStride(0));

        instantiatedGrassComputeShader.SetInt("_PositionOffset", mesh.GetVertexAttributeOffset(VertexAttribute.Position));
        instantiatedGrassComputeShader.SetInt("_NormalOffset", mesh.GetVertexAttributeOffset(VertexAttribute.Normal));
        instantiatedGrassComputeShader.SetInt("_TangentOffset", mesh.GetVertexAttributeOffset(VertexAttribute.Tangent));

        // Set up the camera frustum planes.
        instantiatedGrassComputeShader.SetVectorArray("_CameraFrustumPlanes", new Vector4[6]);

        // Set compute shader textures.
        instantiatedGrassComputeShader.SetTexture(idGrassKernel, "_WindTexture", m_grassSettings.windNoiseTexture != null ? m_grassSettings.windNoiseTexture : Texture2D.blackTexture);

        // Set compute shader variables.
        instantiatedGrassComputeShader.SetVector("_LODSettings", new Vector3(m_grassSettings.cameraLODNear, m_grassSettings.cameraLODFar, m_grassSettings.cameraLODFactor));

        instantiatedGrassComputeShader.SetInt("_SourceTriangleCount", sourceTriangleCount);
        instantiatedGrassComputeShader.SetInt("_MaxBladeSegments", m_grassSettings.maxBladeSegments);
        instantiatedGrassComputeShader.SetInt("_GrassBladesPerTriangle", m_grassSettings.grassBladesPerTriangle);

        instantiatedGrassComputeShader.SetFloat("_GrassHeight", m_grassSettings.grassHeight);
        instantiatedGrassComputeShader.SetFloat("_GrassWidth", m_grassSettings.grassWidth);
        instantiatedGrassComputeShader.SetFloat("_GrassBend", m_grassSettings.grassBend);
        instantiatedGrassComputeShader.SetFloat("_GrassSlant", m_grassSettings.grassSlant);
        instantiatedGrassComputeShader.SetFloat("_GrassRigidity", Mathf.Max(1, m_grassSettings.grassRigidity));

        instantiatedGrassComputeShader.SetFloat("_GrassHeightVariation", m_grassSettings.grassHeightVariation);
        instantiatedGrassComputeShader.SetFloat("_GrassWidthVariation", m_grassSettings.grassWidthVariation);
        instantiatedGrassComputeShader.SetFloat("_GrassBendVariation", m_grassSettings.grassBendVariation);
        instantiatedGrassComputeShader.SetFloat("_GrassSlantVariation", m_grassSettings.grassSlantVariation);
        instantiatedGrassComputeShader.SetFloat("_GrassRigidityVariation", m_grassSettings.grassRigidityVariation);

        instantiatedGrassComputeShader.SetFloat("_WindStrength", m_grassSettings.windStrength);
        instantiatedGrassComputeShader.SetFloat("_WindTimeMultiplier", m_grassSettings.windTimeMultiplier);
        instantiatedGrassComputeShader.SetFloat("_WindTextureScale", m_grassSettings.windTextureScale);
        instantiatedGrassComputeShader.SetFloat("_WindPositionScale", m_grassSettings.windPositionScale);

        // Calculate the dispatch size.
        instantiatedGrassComputeShader.GetKernelThreadGroupSizes(idGrassKernel, out uint threadGroupSizeTriangles, out uint threadGroupSizePerTriangle, out _);
        dispatchSize = new Vector3Int(
            Mathf.CeilToInt((float)sourceTriangleCount / threadGroupSizeTriangles),
            Mathf.CeilToInt((float)m_grassSettings.grassBladesPerTriangle / threadGroupSizePerTriangle),
            1
        );

        // Set the indirect draw indexed args reset data.
        indirectDrawIndexedArgsReset[0] = m_grassSettings.grassBladeMesh.GetIndexCount(0);

        // Initialize GPUInstancing compute shader buffers.
        grassInstancesBuffer = new ComputeBuffer(sourceTriangleCount * m_grassSettings.grassBladesPerTriangle, GRASS_INSTANCE_STRIDE, ComputeBufferType.Append);
        grassInstancesBuffer.SetCounterValue(0);
        indirectDrawIndexedArgs = new GraphicsBuffer(GraphicsBuffer.Target.IndirectArguments, 5, sizeof(int));
        indirectDrawIndexedArgs.SetData(indirectDrawIndexedArgsReset);

        // Set GPUInstancing compute shader buffers.
        instantiatedGrassComputeShader.SetBuffer(idGrassKernel, "_ProceduralGrassInstances", grassInstancesBuffer);
        instantiatedGrassComputeShader.SetBuffer(idGrassKernel, "_IndirectDrawIndexedArgs", indirectDrawIndexedArgs);

        // Set GPUInstancing material properties.
        instantiatedMaterial.SetBuffer("_GrassInstances", grassInstancesBuffer);

        // Get TextureMapsGenerator component, this fails depending on the order of components in the inspector.
        if (GetComponent<TextureMapsGenerator>() != null) {
            GetComponent<TextureMapsGenerator>().SetupShaderVariables(instantiatedGrassComputeShader, idGrassKernel);
            instantiatedGrassComputeShader.EnableKeyword("_USE_TEXTURE_MAPS");
        } else {
            instantiatedGrassComputeShader.DisableKeyword("_USE_TEXTURE_MAPS");
        }

        // Set the initialized flag.
        _isInitialized = true;
    }

    void OnDisable() {

        // Release Mesh buffers.
        indexBuffer?.Release();
        vertexBuffer?.Release();

        // Release GPU Instanced Grass buffers.
        grassInstancesBuffer?.Release();
        indirectDrawIndexedArgs?.Release();

        // Destroy the instantiated compute shader and material.
        if (Application.isPlaying) {
            Destroy(instantiatedGrassComputeShader);
            Destroy(instantiatedMaterial);
        } else {
            DestroyImmediate(instantiatedGrassComputeShader);
            DestroyImmediate(instantiatedMaterial);
        }

        // Set the initialized flag.
        _isInitialized = false;
    }

    // LateUpdate is called after all Update functions have been called.
    // LateUpdate is used to ensure that the underlying mesh data is updated before the compute shader is dispatched.
    void LateUpdate() {

        // If in editor mode, reinitialize the renderer to make sure changes are applied.
        if (!Application.isPlaying) {
            OnDisable();
            OnEnable();
        }

        // Check if the renderer is initialized.
        if (!_isInitialized) { OnEnable(); }
        if (!_isInitialized) { return; }

        // Clear the draw and indirect args buffers from the previous frame.
        grassInstancesBuffer.SetCounterValue(0);
        indirectDrawIndexedArgs.SetData(indirectDrawIndexedArgsReset);

        // Update compute shader with frame specific data.
        instantiatedGrassComputeShader.SetVector("_Time", new Vector4(0, Time.timeSinceLevelLoad, 0, 0));
        instantiatedGrassComputeShader.SetVector("_CameraPositionWS", Camera.main.transform.position);
        instantiatedGrassComputeShader.SetVector("_CameraDirectionWS", Camera.main.transform.forward);
        instantiatedGrassComputeShader.SetFloat("_CameraFOV", Camera.main.fieldOfView);
        instantiatedGrassComputeShader.SetMatrix("_LocalToWorld", transform.localToWorldMatrix);

        // Update Camera Frustum Planes.
        Plane[] frustumPlanes = GeometryUtility.CalculateFrustumPlanes(Camera.main);
        Vector4[] frustumPlanesArray = new Vector4[6];
        for (int i = 0; i < 6; i++) {
            frustumPlanesArray[i] = new Vector4(frustumPlanes[i].normal.x, frustumPlanes[i].normal.y, frustumPlanes[i].normal.z, frustumPlanes[i].distance);
        }
        instantiatedGrassComputeShader.SetVectorArray("_CameraFrustumPlanes", frustumPlanesArray);

        // Dispatch the compute shader.
        instantiatedGrassComputeShader.Dispatch(idGrassKernel, dispatchSize.x, dispatchSize.y, dispatchSize.z);

        // Draw the grass.
        DrawGPUInstancedGrass();
    }

    private void DrawGPUInstancedGrass() {

        // Set the render parameters.
        RenderParams rp = new RenderParams(instantiatedMaterial);
        rp.shadowCastingMode = ShadowCastingMode.Off;
        //rp.receiveShadows = true;

        // Set the world render bounds, expand the bounds to account for the grass width and height.
        Bounds bounds = meshRenderer.bounds;
        bounds.Expand(Mathf.Max(m_grassSettings.grassHeight + m_grassSettings.grassHeightVariation, m_grassSettings.grassWidth + m_grassSettings.grassWidthVariation) * 2.0f);
        rp.worldBounds = bounds;
        rp.shadowCastingMode = m_grassSettings.shadowCastingMode;

        // Draw GPU Instanced meshes.
        Graphics.RenderMeshIndirect(rp, m_grassSettings.grassBladeMesh, indirectDrawIndexedArgs);
    }
}
