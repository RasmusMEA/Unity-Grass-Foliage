#pragma kernel ClearHiZMipMap
#pragma kernel CopyDepthToHiZMipMap
#pragma kernel GenerateHiZMipMap

// Includes
#include "HiZOcclusionCulling.hlsl"

// Current MipMap level to generate
int _MipLevel;

[numthreads(64,1,1)]
void ClearHiZMipMap(uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)_ScreenParams.x * (uint)_ScreenParams.y) { return; }
    
    int2 texelPos = int2(id.x % _ScreenParams.x, id.x / _ScreenParams.x);
    _HiZBuffer[texelPos] = 0.0f;
}

[numthreads(64,1,1)]
void CopyDepthToHiZMipMap(uint3 id : SV_DispatchThreadID) {
    if (id.x >= (uint)_ScreenParams.x * (uint)_ScreenParams.y) { return; }

    int2 texelPos = int2(id.x % _ScreenParams.x, id.x / _ScreenParams.x);
    _HiZBuffer[texelPos] = LOAD_TEXTURE2D_X(_CameraDepthTexture, texelPos).r;
}

[numthreads(64,1,1)]
void GenerateHiZMipMap(uint3 id : SV_DispatchThreadID) {
    uint mipWidth = (uint)_ScreenParams.x >> _MipLevel;
    uint mipHeight = (uint)_ScreenParams.y >> _MipLevel;

    // Check if its the first MipMap level or if the pixel is out of bounds
    if (_MipLevel == 0 || id.x >= mipWidth * mipHeight) { return; }

    // Get the current texel position
    int2 texelPos = int2(id.x % mipWidth, id.x / mipWidth);
    int2 prevMipTexelPos = texelPos << 1;

    // Calculate the mip offsets
    int2 prevMipOffset = GetMipOffset(_MipLevel - 1);
    int2 mipOffset = GetMipOffset(_MipLevel);

    // Get the 4 texels from the previous MipMap level to downsample
    float4 texels;
    texels.x = _HiZBuffer[prevMipTexelPos + prevMipOffset + int2(0, 0)].r;
    texels.y = _HiZBuffer[prevMipTexelPos + prevMipOffset + int2(1, 0)].r;
    texels.z = _HiZBuffer[prevMipTexelPos + prevMipOffset + int2(0, 1)].r;
    texels.w = _HiZBuffer[prevMipTexelPos + prevMipOffset + int2(1, 1)].r;

    // Store the minimum depth value in the current MipMap level
    _HiZBuffer[texelPos + mipOffset] = min(min(texels.x, texels.y), min(texels.z, texels.w));
}
