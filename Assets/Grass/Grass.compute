#pragma kernel Main

#pragma multi_compile GPU_INSTANCING GPU_GENERATION

// Global Includes
#include "Mesh.hlsl"
#include "Grass.hlsl"
#include "GrassShading.hlsl"

#if GPU_INSTANCING

    // Instanced Output: Grass Blades and Indirect Draw Arguments
    AppendStructuredBuffer<GrassInstance> _ProceduralGrassInstances;
    RWStructuredBuffer<IndirectDrawIndexedArgs> _IndirectDrawIndexedArgs;

#elif GPU_GENERATION

    struct IndirectArgs {
        uint vertexCountPerInstance;
        uint instanceCount;
        uint startVertexIndex;
        uint startInstanceIndex;
    };

    // Procedural Output: Grass Blades and Indirect Draw Arguments
    AppendStructuredBuffer<GeneratedTriangle> _ProceduralTriangles;
    RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;
#endif // GPU_GENERATION

// Variables set by the renderer
float4x4 _LocalToWorld;

// Main compute shader
[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _IndexCount / 3 || id.y >= _GrassBladesPerTriangle) { return; }

    // Random numbers
    float r = rand(id.x * 269 + id.y * 293);
    float r2 = rand(id.x * 107 + id.y * 571);

    // Randomized triangle coefficients
    float3 randomizedCoefficients = UniformRandomBarycentricCoefficients(id.x * 701 + id.y * 109, id.x * 461 + id.y * 1031);

    // Get the vertex indices, if the index buffer is 16-bit, the indices are packed and need to be unpacked
    uint3 v_id = GetTriangleIndices(id);

    // Get the vertices
    float3 v0 = asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _PositionOffset));
    float3 v1 = asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _PositionOffset));
    float3 v2 = asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _PositionOffset));

    // Get the normals
    float3 n0 = asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _NormalOffset));
    float3 n1 = asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _NormalOffset));
    float3 n2 = asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _NormalOffset));

    // Get the tangents
    float4 t0 = asfloat(_VertexBuffer.Load4(v_id.x * _VertexStride + _TangentOffset));
    float4 t1 = asfloat(_VertexBuffer.Load4(v_id.y * _VertexStride + _TangentOffset));
    float4 t2 = asfloat(_VertexBuffer.Load4(v_id.z * _VertexStride + _TangentOffset));

    // Calculate average position, normal and tangent
    float3 position = randomizedCoefficients.x * v0 + randomizedCoefficients.y * v1 + randomizedCoefficients.z * v2;
    float3 normal = normalize(randomizedCoefficients.x * n0 + randomizedCoefficients.y * n1 + randomizedCoefficients.z * n2);
    float3 tangent = normalize(randomizedCoefficients.x * t0.xyz + randomizedCoefficients.y * t1.xyz + randomizedCoefficients.z * t2.xyz);

    // Translate the position to world space
    position = mul(_LocalToWorld, float4(position, 1)).xyz;
    normal = normalize(mul(_LocalToWorld, float4(normal, 0)).xyz);
    tangent = normalize(mul(_LocalToWorld, float4(tangent, 0)).xyz);

    // Create tangent to world space matrix
    float3 bitangent = normalize(cross(normal, tangent));
    float3x3 tangentToWorld = transpose(float3x3(tangent, bitangent, normal));

    // Create the direction matrix
    float3x3 directionMatrix = AngleAxis3x3(r2 * r2 * 2 * PI, float3(0, 0, 1));
    float3 windDirectionWS = GetWindDirection(position, normal) * _WindStrength;

    // Get the wind UV coordinate
    float2 heightUV = (position.xz * _WindPositionScale) * _WindTextureScale;
    float2 heightNoise = SAMPLE_TEXTURE2D_LOD(_WindTexture, sampler_WindTexture, heightUV, 0).rg * 2 - 1;

    // Grass variation
    float height = max(0, _GrassHeight + _GrassHeightVariation * (heightNoise.x + heightNoise.y));
    float width = _GrassWidth + _GrassWidthVariation * (r  * r2 * 2 - 1);
    float bend = _GrassBend + _GrassBendVariation * (r2 * 2 - 1);
    float slant = _GrassSlant + _GrassSlantVariation * (r * r * 2 - 1);
    float rigidity = _GrassRigidity + _GrassRigidityVariation * (r2 * 2 - 1);

    // Cull the grass blade
    if (CullGrassBlade(position, max(height, width), height, normal)) { return; }
    
    // Cull randomly based on the distance, to reduce the number of blades
    if (r * (1 - height) > 250 / pow(distance(position, _CameraPositionWS), 2)) {
        return;
    } else {
        width *= max(1, 3 - 75 / distance(position, _CameraPositionWS));
    }

    #if GPU_INSTANCING

        // Create the grass blade
        GrassInstance grassInstance;
        grassInstance.positionWS = position;
        grassInstance.normalWS = normal;
        grassInstance.facing = 0;
        
        grassInstance.type = 0;

        grassInstance.height = height;
        grassInstance.width = width;
        grassInstance.bend = bend;

        grassInstance.windDirection = windDirectionWS;

        // Add the grass blade to the buffer
        _ProceduralGrassInstances.Append(grassInstance);

        // Increase the instance count
        InterlockedAdd(_IndirectDrawIndexedArgs[0].instanceCount, 1);

    #elif GPU_GENERATION

        // Get the blade segment count
        uint bladeSegmentCount = GetBladeSegments(position, height);
        uint triangleCount = 2 * bladeSegmentCount - 1;

        // Create the grass blade vertices
        GeneratedVertex vertices[MAX_BLADE_POINTS];
        for (uint i = 0; i < 2 * bladeSegmentCount; i++) {
            float h = (2*(i/2)) / (float)(2 * bladeSegmentCount);

            // Calculate the offset for the vertex
            float3 offsetTS = float3(-width + width * (i % 2) * 2, 0, height * h);
            float3x3 bendMatrix = GetBladeBendMatrix(h, rigidity, bend);
            float3x3 windMatrixWS = AngleAxis3x3(h * windDirectionWS.z, windDirectionWS);

            // Add the vertex point to the blade
            vertices[i].positionWS = position + mul(windMatrixWS, mul(tangentToWorld, mul(directionMatrix, mul(bendMatrix, offsetTS))));
            vertices[i].uv = float2(i % 2, h);
        }

        // Add the tip
        float3x3 bendMatrix = GetBladeBendMatrix(1, rigidity, bend);
        float3x3 windMatrixWS = AngleAxis3x3(1 * windDirectionWS.z, windDirectionWS);
        vertices[2 * bladeSegmentCount].positionWS = position + mul(windMatrixWS, mul(tangentToWorld, mul(directionMatrix, mul(bendMatrix, float3(0, 0, height)))));
        vertices[2 * bladeSegmentCount].uv = float2(0.5, 1);

        // Generate the triangles
        for (i = 0; i < triangleCount; i++) {
            GeneratedTriangle tri = (GeneratedTriangle)0;
            tri.normal = normal;
            tri.vertices[0] = vertices[i];
            tri.vertices[1] = vertices[i + 1];
            tri.vertices[2] = vertices[i + 2];
            _ProceduralTriangles.Append(tri);
        }
        
        // Increase the vertex count
        InterlockedAdd(_IndirectArgsBuffer[0].vertexCountPerInstance, triangleCount * 3);
    #endif // GPU_GENERATION
}
