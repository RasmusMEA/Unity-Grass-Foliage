#pragma kernel Main

#pragma multi_compile OBJECT_SPACE WORLD_SPACE
#pragma multi_compile _ _USE_TEXTURE_MAPS

// Global Includes
#include "Grass.hlsl"
#include "GrassShading.hlsl"
#include "Assets/ShaderLibrary/Common/Mesh.hlsl"

#ifdef _USE_TEXTURE_MAPS
    #include "Assets/Vegetation/TextureMaps.hlsl"
#endif

// Instanced Output: Grass Blades and Indirect Draw Arguments
AppendStructuredBuffer<GrassInstance> _ProceduralGrassInstances;
RWStructuredBuffer<IndirectDrawIndexedArgs> _IndirectDrawIndexedArgs;

// Variables set by the renderer
float4x4 _LocalToWorld;
bool _UseTerrainMaps;

// Main compute shader
[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _IndexCount / 3 || id.y >= _GrassBladesPerTriangle) { return; }

    // Get the vertex indices, if the index buffer is 16-bit, the indices are packed and need to be unpacked
    uint3 v_id = GetTriangleIndices(id);

    // Get the vertices of the triangle
    float3 vertex0 = asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _PositionOffset));
    float3 vertex1 = asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _PositionOffset));
    float3 vertex2 = asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _PositionOffset));

    // Get center position in object space for sampling random values
    #if OBJECT_SPACE
        float3 hashPosition = (vertex0 + vertex1 + vertex2) / 3;

    // Get center position in world space for sampling random values
    #elif WORLD_SPACE
        float3 hashPosition = mul(_LocalToWorld, float4((vertex0 + vertex1 + vertex2) / 3, 1)).xyz;

        float3 v0WS = mul(_LocalToWorld, float4(vertex0, 1)).xyz;
        float3 v1WS = mul(_LocalToWorld, float4(vertex1, 1)).xyz;
        float3 v2WS = mul(_LocalToWorld, float4(vertex2, 1)).xyz;

        float v0Hash = v0WS.x * 5 + v0WS.y + v0WS.z * 11;
        float v1Hash = v1WS.x * 5 + v1WS.y + v1WS.z * 11;
        float v2Hash = v2WS.x * 5 + v2WS.y + v2WS.z * 11;

        int3 order = int3(0, 1, 2);

        if (v1Hash < v0Hash) { int temp = order.x; float temp2 = v0Hash; order.x = order.y; v0Hash = v1Hash; order.y = temp; v1Hash = temp2; }
        if (v2Hash < v0Hash) { int temp = order.x; float temp2 = v0Hash; order.x = order.z; v0Hash = v2Hash; order.z = temp; v2Hash = temp2; }
        if (v2Hash < v1Hash) { int temp = order.y; float temp2 = v1Hash; order.y = order.z; v1Hash = v2Hash; order.z = temp; v2Hash = temp2; }
    #endif

    float hash = dot(floor(hashPosition * 100) / 100, float3(6047, 4871, 5237));

    // Random numbers
    uint positionHash = asuint(rand(hash)) ^ asuint(hash);
    float r = rand(positionHash * 701 ^ id.y * 109);
    float r2 = rand(positionHash * 461 ^ id.y * 1031);

    // Randomized triangle coefficients
    float3 randomizedCoefficients = BarycentricCoefficients(r, r2);

    #if WORLD_SPACE
        randomizedCoefficients = float3(
            randomizedCoefficients[order.x],
            randomizedCoefficients[order.y],
            randomizedCoefficients[order.z]
        );
    #endif
    
    // Get the position
    float3 position = mul(_LocalToWorld, float4(
        vertex0 * randomizedCoefficients.x +
        vertex1 * randomizedCoefficients.y +
        vertex2 * randomizedCoefficients.z,
        1
    )).xyz;

    // Get the normal
    float3 normal = normalize(mul(_LocalToWorld, float4(
        asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _NormalOffset)) * randomizedCoefficients.x +
        asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _NormalOffset)) * randomizedCoefficients.y +
        asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _NormalOffset)) * randomizedCoefficients.z,
        0
    )).xyz);

    // Create the direction matrix
    float3 windDirectionWS = GetWindDirection(position + float3((r * r - 0.5), (r2 * r2 - 0.5), (r2 * r - 0.5)), normal) * _WindStrength;

    // Get the wind UV coordinate
    float2 heightUV = (position.xz * _WindPositionScale) * _WindTextureScale;
    float2 heightNoise = SAMPLE_TEXTURE2D_LOD(_WindTexture, sampler_WindTexture, heightUV, 0).rg * 2 - 1;

    // Grass variation
    float height = max(0, _GrassHeight + _GrassHeightVariation * (heightNoise.x + heightNoise.y));
    float width = _GrassWidth + _GrassWidthVariation * (r * r2 * 2 - 1);
    float bend = _GrassBend + _GrassBendVariation * (r2 * 2 - 1);
    float slant = _GrassSlant + _GrassSlantVariation * (r * r * 2 - 1);
    float rigidity = _GrassRigidity + _GrassRigidityVariation * (r2 * 2 - 1);

    // Cull randomly based on the distance, to reduce the number of blades
    if (frac(asfloat(asuint(r) ^ asuint(positionHash))) * (1 - height) > 25000 / pow(distance(position, _CameraPositionWS), 2)) {
        return;
    }

    // Cull the grass blade
    if (CullGrassBlade(position, max(height, width), height, normal)) { return; }

    // Get the terrain data
    #ifdef _USE_TEXTURE_MAPS
        bool validTerrain = true;
        bool validNormal = true;
        
        float4 terrainData = SampleTextureWorldPosition(_TerrainMapView, sampler_TerrainMapView, position, validTerrain);
        float3 terrainNormal = normalize(SampleTextureWorldPosition(_NormalMapView, sampler_NormalMapView, position, validNormal).xyz * 2 - 1);
        
        normal = float3(terrainNormal.x, terrainNormal.z, terrainNormal.y);
        height = (terrainData.w + 0.5) * _GrassHeight;

        if (terrainData.x < 0.5) { return; }
        if (!validTerrain || !validNormal) { return; }
    #endif

    // Widen the grass blade based on the distance
    width *= max(1, 3 - 75 / distance(position, _CameraPositionWS));

    // Create the grass blade
    GrassInstance grassInstance;
    grassInstance.positionWS = position;
    grassInstance.normalWS = normal;
    grassInstance.facing = 0;
    
    grassInstance.type = 0;
    grassInstance.hash = asfloat(asuint(r) ^ asuint(positionHash));

    grassInstance.height = height;
    grassInstance.width = width;
    grassInstance.bend = bend;

    grassInstance.windDirection = windDirectionWS;

    // Add the grass blade to the buffer
    _ProceduralGrassInstances.Append(grassInstance);

    // Increase the instance count
    InterlockedAdd(_IndirectDrawIndexedArgs[0].instanceCount, 1);
}
