#pragma kernel Main

#pragma multi_compile GPU_INSTANCING GPU_GENERATION
#pragma multi_compile OBJECT_SPACE WORLD_SPACE

// Global Includes
#include "Mesh.hlsl"
#include "Grass.hlsl"
#include "GrassShading.hlsl"

#if GPU_INSTANCING

    // Instanced Output: Grass Blades and Indirect Draw Arguments
    AppendStructuredBuffer<GrassInstance> _ProceduralGrassInstances;
    RWStructuredBuffer<IndirectDrawIndexedArgs> _IndirectDrawIndexedArgs;

#elif GPU_GENERATION

    struct IndirectArgs {
        uint vertexCountPerInstance;
        uint instanceCount;
        uint startVertexIndex;
        uint startInstanceIndex;
    };

    // Procedural Output: Grass Blades and Indirect Draw Arguments
    AppendStructuredBuffer<GeneratedTriangle> _ProceduralTriangles;
    RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer;

    // Output buffers for the generated geometry
    RWByteAddressBuffer _GeneratedIndexBuffer;
    //RWByteAddressBuffer _GeneratedVertexBuffer;

#endif // GPU_GENERATION

// Variables set by the renderer
float4x4 _LocalToWorld;

// Main compute shader
[numthreads(8,8,1)]
void Main(uint3 id : SV_DispatchThreadID) {
    if (id.x >= _IndexCount / 3 || id.y >= _GrassBladesPerTriangle) { return; }

    // Get the vertex indices, if the index buffer is 16-bit, the indices are packed and need to be unpacked
    uint3 v_id = GetTriangleIndices(id);

    // Get the vertices of the triangle
    float3 vertex0 = asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _PositionOffset));
    float3 vertex1 = asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _PositionOffset));
    float3 vertex2 = asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _PositionOffset));

    // Get center position in object space for sampling random values
    #if OBJECT_SPACE
        float3 hashPosition = (vertex0 + vertex1 + vertex2) / 3;

    // Get center position in world space for sampling random values
    #elif WORLD_SPACE
        float3 hashPosition = mul(_LocalToWorld, float4((vertex0 + vertex1 + vertex2) / 3, 1)).xyz;

        float3 v0WS = mul(_LocalToWorld, float4(vertex0, 1)).xyz;
        float3 v1WS = mul(_LocalToWorld, float4(vertex1, 1)).xyz;
        float3 v2WS = mul(_LocalToWorld, float4(vertex2, 1)).xyz;

        float v0Hash = v0WS.x * 5 + v0WS.y + v0WS.z * 11;
        float v1Hash = v1WS.x * 5 + v1WS.y + v1WS.z * 11;
        float v2Hash = v2WS.x * 5 + v2WS.y + v2WS.z * 11;

        int3 order = int3(0, 1, 2);

        if (v1Hash < v0Hash) { int temp = order.x; float temp2 = v0Hash; order.x = order.y; v0Hash = v1Hash; order.y = temp; v1Hash = temp2; }
        if (v2Hash < v0Hash) { int temp = order.x; float temp2 = v0Hash; order.x = order.z; v0Hash = v2Hash; order.z = temp; v2Hash = temp2; }
        if (v2Hash < v1Hash) { int temp = order.y; float temp2 = v1Hash; order.y = order.z; v1Hash = v2Hash; order.z = temp; v2Hash = temp2; }
    #endif

    hashPosition = float3(floor(hashPosition.x * 100) / 100, floor(hashPosition.y * 100) / 100, floor(hashPosition.z * 100) / 100);

    // Random numbers
    uint positionHash = asuint(rand(hashPosition.x * 6047 + hashPosition.y * 4871 + hashPosition.z * 5237)) ^ asuint(hashPosition.x * 6047 + hashPosition.y * 4871 + hashPosition.z * 5237);
    float r = rand(positionHash * 701 ^ id.y * 109);
    float r2 = rand(positionHash * 461 ^ id.y * 1031);

    // Randomized triangle coefficients
    float3 randomizedCoefficients = BarycentricCoefficients(r, r2);

    #if WORLD_SPACE
        randomizedCoefficients = float3(
            randomizedCoefficients[order.x],
            randomizedCoefficients[order.y],
            randomizedCoefficients[order.z]
        );
    #endif
    
    // Get the position
    float3 position = mul(_LocalToWorld, float4(
        vertex0 * randomizedCoefficients.x +
        vertex1 * randomizedCoefficients.y +
        vertex2 * randomizedCoefficients.z,
        1
    )).xyz;

    // Get the normal
    float3 normal = normalize(mul(_LocalToWorld, float4(
        asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _NormalOffset)) * randomizedCoefficients.x +
        asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _NormalOffset)) * randomizedCoefficients.y +
        asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _NormalOffset)) * randomizedCoefficients.z,
        0
    )).xyz);

    // Create the direction matrix
    float3 windDirectionWS = GetWindDirection(position + float3((r * r - 0.5), (r2 * r2 - 0.5), (r2 * r - 0.5)), normal) * _WindStrength;

    // Get the wind UV coordinate
    float2 heightUV = (position.xz * _WindPositionScale) * _WindTextureScale;
    float2 heightNoise = SAMPLE_TEXTURE2D_LOD(_WindTexture, sampler_WindTexture, heightUV, 0).rg * 2 - 1;

    // Grass variation
    float height = max(0, _GrassHeight + _GrassHeightVariation * (heightNoise.x + heightNoise.y));
    float width = _GrassWidth + _GrassWidthVariation * (r * r2 * 2 - 1);
    float bend = _GrassBend + _GrassBendVariation * (r2 * 2 - 1);
    float slant = _GrassSlant + _GrassSlantVariation * (r * r * 2 - 1);
    float rigidity = _GrassRigidity + _GrassRigidityVariation * (r2 * 2 - 1);

    // Cull the grass blade
    if (CullGrassBlade(position, max(height, width), height, normal)) { return; }
    
    // Cull randomly based on the distance, to reduce the number of blades
    if (r * (1 - height) > 25000 / pow(distance(position, _CameraPositionWS), 2)) {
        return;
    }

    // Widen the grass blade based on the distance
    width *= max(1, 3 - 75 / distance(position, _CameraPositionWS));

    #if GPU_INSTANCING

        // Create the grass blade
        GrassInstance grassInstance;
        grassInstance.positionWS = position;
        grassInstance.normalWS = normal;
        grassInstance.facing = 0;
        
        grassInstance.type = 0;
        grassInstance.hash = asfloat(asuint(r) ^ asuint(positionHash));

        grassInstance.height = height;
        grassInstance.width = width;
        grassInstance.bend = bend;

        grassInstance.windDirection = windDirectionWS;

        // Add the grass blade to the buffer
        _ProceduralGrassInstances.Append(grassInstance);

        // Increase the instance count
        InterlockedAdd(_IndirectDrawIndexedArgs[0].instanceCount, 1);

    #elif GPU_GENERATION

        // Get the blade segment count, triangle count and vertex count
        uint bladeSegmentCount = GetBladeSegments(position, height);
        uint triangleCount = 2 * bladeSegmentCount - 1;
        uint indexCount = triangleCount * 3;
        uint vertexCount = triangleCount + 2;

        // Increase the index count to allocate space for the blade
        //InterlockedAdd(_IndirectArgsBuffer[0].indexCountPerInstance, indexCount);
        InterlockedAdd(_IndirectArgsBuffer[0].vertexCountPerInstance, indexCount);

        // Get the tangent
        float3 tangent = normalize(mul(_LocalToWorld, float4(
            asfloat(_VertexBuffer.Load3(v_id.x * _VertexStride + _TangentOffset)) * randomizedCoefficients.x +
            asfloat(_VertexBuffer.Load3(v_id.y * _VertexStride + _TangentOffset)) * randomizedCoefficients.y +
            asfloat(_VertexBuffer.Load3(v_id.z * _VertexStride + _TangentOffset)) * randomizedCoefficients.z,
            0
        ))).xyz;

        // Create tangent to world space matrix and direction matrix
        float3 bitangent = normalize(cross(normal, tangent));
        float3x3 tangentToWorld = transpose(float3x3(tangent, bitangent, normal));
        float3x3 directionMatrix = AngleAxis3x3(asfloat(asuint(r) ^ asuint(positionHash)) * 2 * PI, float3(0, 0, 1));

        // Create the grass blade vertices
        GeneratedVertex vertices[MAX_BLADE_POINTS];
        for (uint i = 0; i < 2 * bladeSegmentCount; i++) {
            float h = (2*(i/2)) / (float)(2 * bladeSegmentCount);

            // Calculate the offset for the vertex
            float3 offsetTS = float3(-width + width * (i % 2) * 2, 0, height * h);
            float3x3 bendMatrix = GetBladeBendMatrix(h, rigidity, bend);
            float3x3 windMatrixWS = AngleAxis3x3(h * windDirectionWS.z, windDirectionWS);

            // Add the vertex point to the blade
            vertices[i].positionWS = position + mul(windMatrixWS, mul(tangentToWorld, mul(directionMatrix, mul(bendMatrix, offsetTS))));
            vertices[i].uv = float2(i % 2, h);
        }

        // Add the tip
        float3x3 bendMatrix = GetBladeBendMatrix(1, rigidity, bend);
        float3x3 windMatrixWS = AngleAxis3x3(1 * windDirectionWS.z, windDirectionWS);
        vertices[2 * bladeSegmentCount].positionWS = position + mul(windMatrixWS, mul(tangentToWorld, mul(directionMatrix, mul(bendMatrix, float3(0, 0, height)))));
        vertices[2 * bladeSegmentCount].uv = float2(0.5, 1);

        // Generate the triangles
        for (i = 0; i < triangleCount; i++) {
            GeneratedTriangle tri = (GeneratedTriangle)0;
            tri.normal = normal;
            tri.vertices[0] = vertices[i];
            tri.vertices[1] = vertices[i + 1];
            tri.vertices[2] = vertices[i + 2];
            _ProceduralTriangles.Append(tri);
        }

    #endif // GPU_GENERATION
}
